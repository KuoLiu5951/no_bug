
<!-- saved from url=(0062)http://web.cse.ohio-state.edu/~mikebond/papers.html#vindicator -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>
    Publication Details
  </title>

  <script src="./high-coverage_files/hm.js.下载"></script><script src="./high-coverage_files/jquery.js.下载"></script>
  <!--<script src="namefix.js"></script>-->
  <script>
  $(document).ready(function() {
    $.getScript("namefix.js");
  });
  </script>

  </head><body bgcolor="#ffffff" text="#000000">

  <h3> Publications of <a href="http://web.cse.ohio-state.edu/~mikebond/plass.html">PLaSS</a> and Mike Bond</h3>

  <a name="arc"></a>
  <hr>
  <h3> Rethinking Support for Region Conflict Exceptions </h3>
    <a href="https://www.cse.iitk.ac.in/users/swarnendu/">Swarnendu Biswas</a>,
    Rui Zhang,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>, and
    <a href="https://brandonlucia.com/">Brandon Lucia</a>
    <p>
    IEEE International Parallel and Distributed Processing Symposium
    (<a href="http://www.ipdps.org/">IPDPS 2019</a>),
    Rio de Janeiro, Brazil, May 2019
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/arc-ipdps-2019.pdf">PDF</a>
    <!--<p>
    <b>Talk (by Swarnendu Biswas):</b> &nbsp;
    <a href=arc-ipdps-2019-talk.pptx>PPTX</a> &nbsp;
    <a href=arc-ipdps-2019-talk.pdf>PDF</a>-->
    </p><p>
    <b>Source code:</b> &nbsp; Coming soon
    <!--Available at <a href=https://github.com/PLaSSticity/???>https://github.com/PLaSSticity/???</a>-->
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
Current shared-memory systems provide well-defined execution semantics <i>only for</i> data-race-free executions. A 
state-of-the-art technique called <i>Conflict Exceptions</i> (CE) extends M(O)ESI-based coherence to provide defined 
semantics to <i>all</i> program executions. However, CE incurs significant performance costs because of its need to 
frequently access metadata in memory.
<p>
In this work, we explore designs for practical architecture support for region conflict exceptions. First, we 
propose an on-chip metadata cache called access information memory (AIM) to reduce memory accesses in CE. The 
extended design is called <i>CE+</i>. In spite of the AIM, CE+ stresses or saturates the on-chip interconnect and the 
off-chip memory network bandwidth because of its reliance on eager write-invalidation-based coherence. We 
explore whether detecting conflicts is <i>potentially</i> better suited to cache coherence based on release 
consistency and self-invalidation, rather than M(O)ESI-based coherence. We realize this insight in a novel 
architecture design called <i>ARC</i>.
</p><p>
Our evaluation shows that CE+ improves the run-time performance and energy usage over CE for several 
applications across different core counts, but can suffer performance penalties from network saturation. ARC 
generally outperforms CE, and is competitive with CE+ on average while stressing the on-chip interconnect and 
off-chip memory network much less, showing that coherence based on release consistency and self-invalidation 
is well suited to detecting region conflicts.
    </p></blockquote>
    <br>

  <a name="vindicator"></a>
  <hr>
  <h3> High-Coverage, Unbounded Sound Predictive Race Detection </h3>
    Jake Roemer,
    Kaan Genç, and
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>
    <p>
    ACM SIGPLAN Conference on
    Programming Language Design and Implementation
    (<a href="https://pldi18.sigplan.org/">PLDI 2018</a>),
    Philadelphia, PA, USA, June 2018
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/vindicator-pldi-2018-xtr.pdf">Extended technical report</a> (includes all appendices) &nbsp; &nbsp; <a href="http://web.cse.ohio-state.edu/~mikebond/vindicator-pldi-2018.pdf">Conference version</a> (excludes some appendices)
    </p><p>
    <b>Talk (by Jake Roemer):</b> &nbsp;
    <a href="https://docs.google.com/presentation/d/1fzuHhz5xWKC9zQd-SrEf_T914HYjxbSSJxWtbGrsJj8/">Google Slides</a>
    <!--<a href=vindicator-pldi-2018-talk.pptx>PPTX</a> &nbsp;
    <a href=vindicator-pldi-2018-talk.pdf>PDF</a>-->
    </p><p>
    <b>Source code:</b> &nbsp;
    Available at <a href="https://github.com/PLaSSticity/Vindicator">https://github.com/PLaSSticity/Vindicator</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
Dynamic program analysis can <i>predict</i> data races
knowable from an observed execution, but existing predictive analyses either 
miss races or cannot analyze full program executions.
This paper presents <i>Vindicator</i>, a novel, sound (no false races) predictive approach that
finds more data races than existing predictive approaches.
Vindicator achieves
high coverage by using a new, efficient analysis that finds all possible predictable races but may detect false races.
Vindicator ensures soundness using a novel algorithm that checks each potential race
to determine whether it is a true predictable race.
An evaluation using large Java programs shows that Vindicator finds hard-to-detect
predictable races that existing sound predictive analyses miss, at a comparable performance cost.
    </blockquote>
    <br>

  <a name="fib"></a>
  <hr>
  <h3> Instrumentation Bias for Dynamic Data Race Detection </h3>
    <a href="http://cs.wellesley.edu/~bpw/">Benjamin P. Wood</a>
    <a href="http://www.cse.ohio-state.edu/~caoma/">Man Cao</a>,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>, and
    <a href="https://homes.cs.washington.edu/~djg/">Dan Grossman</a>
    <p>
    ACM SIGPLAN International Conference on
    Object-Oriented Programming, Systems, Languages, and Applications
    (<a href="http://2017.splashcon.org/track/splash-2017-OOPSLA">OOPSLA 2017</a>),
    Vancouver, Canada, October 2017
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp; <a href="http://web.cse.ohio-state.edu/~mikebond/fib-oopsla-2017.pdf">PDF</a>
    <!--<p>
    <b>Talk (by Ben Wood):</b> &nbsp;
    <a href=fib-oopsla-2017-talk.pptx>PPTX</a> &nbsp;
    <a href=fib-oopsla-2017-talk.pdf>PDF</a>-->
    </p><p>
    <b>Source code:</b> &nbsp;
    Available at <a href="https://bitbucket.org/bpw/fib">https://bitbucket.org/bpw/fib</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
This paper presents Fast Instrumentation Bias (FIB), a sound and complete dynamic data race detection algorithm that improves performance by reducing or eliminating the costs of analysis atomicity. In addition to checking for errors in target programs, dynamic data race detectors must introduce synchronization to guard against <i>metadata races</i> that may corrupt analysis state and compromise soundness or completeness. Pessimistic analysis synchronization can account for nontrivial performance overhead in a data race detector.  
<p>
The core contribution of FIB is a novel cooperative ownership-based synchronization protocol whose states and transitions are derived purely from preexisting analysis metadata and logic in a standard data race detection algorithm. By exploiting work already done by the analysis, FIB ensures atomicity of dynamic analysis actions with zero additional time or space cost in the common case. Analysis of temporally thread-local or read-shared accesses completes safely with no synchronization. Uncommon write-sharing transitions require synchronous cross-thread coordination to ensure common cases may proceed synchronization-free.  
</p><p>
We implemented FIB in the Jikes RVM Java virtual machine. Experimental evaluation shows that FIB eliminates nearly all instrumentation atomicity costs on programs where data often experience windows of thread-local access. Adaptive extensions to the ownership policy effectively eliminate high coordination costs of the core ownership protocol on programs with high rates of serialized sharing. FIB outperforms a naive pessimistic synchronization scheme by 50% on average. Compared to a tuned optimistic metadata synchronization scheme based on conventional fine-grained atomic compare-and-swap operations, FIB is competitive overall, and up to 17% faster on some programs. Overall, FIB effectively exploits latent analysis and program invariants to bring strong integrity guarantees to an otherwise unsynchronized data race detection algorithm at minimal cost.
    </p></blockquote>
    <br>

  <a name="hybrid-relaxed-tracking-topc"></a>
  <hr>
  <h3> Hybridizing and Relaxing Dependence Tracking for Efficient Parallel Runtime Support </h3>
    <a href="http://www.cse.ohio-state.edu/~caoma/">Man Cao</a>,
    <a href="http://zhangminjia.me/">Minjia Zhang</a>,
    <a href="http://web.cse.ohio-state.edu/~sengupta/">Aritra Sengupta,
    </a><a href="http://users.ices.utexas.edu/~sbiswas/">Swarnendu Biswas</a>, and
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>
    <p>
    ACM Transactions on Parallel Computing
    (<a href="http://topc.acm.org/">TOPC</a>),
    August 2017
    </p><p>
    <b>Paper:</b> &nbsp; <a href="http://web.cse.ohio-state.edu/~mikebond/hybrid-relaxed-tracking-topc-2017.pdf">PDF</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    See the source code for <a href="http://web.cse.ohio-state.edu/~mikebond/papers.html#hybrid-tracking">hybrid tracking</a> and <a href="http://web.cse.ohio-state.edu/~mikebond/papers.html#relaxed-tracking">relaxed tracking</a>.
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
It is notoriously challenging to develop parallel software systems that are both scalable and correct. Runtime support for parallelism—such as multithreaded record and replay, data race detectors, transactional memory, and enforcement of stronger memory models—helps achieve these goals, but existing commodity solutions slow programs substantially to track (i.e., detect or control) an execution’s cross-thread dependencies accurately. Prior work tracks cross-thread dependencies either "pessimistically," slowing every program access, or 
"optimistically," allowing for lightweight instrumentation of most accesses but dramatically slowing accesses that are <i>conflicting</i> (i.e., involved in cross-thread dependencies).
<p>
This article presents two novel approaches that seek to improve the performance of dependence tracking. <i>Hybrid tracking</i> (HT) hybridizes pessimistic and optimistic tracking by overcoming a fundamental mismatch between these two kinds of tracking. HT uses an adaptive, profile-based policy to make runtime decisions about switching between pessimistic and optimistic tracking. <i>Relaxed tracking</i> (RT) attempts to reduce optimistic tracking’s overhead on conflicting accesses by tracking dependencies in a "relaxed" way—meaning that not all dependencies are tracked accurately—while still preserving both program semantics and runtime support’s correctness. To demonstrate the usefulness and potential of HT and RT, we build runtime support based on the two approaches. Our evaluation shows that both approaches offer performance advantages over existing approaches, but there exist challenges and opportunities for further improvement.
</p><p>
HT and RT are distinct solutions to the same problem. It is easier to build runtime support based on HT than on RT, although RT does not incur the overhead of online profiling. This article presents the two approaches together to inform and inspire future designs for efficient parallel runtime support.
    </p></blockquote>
    <br>

  <a name="avalon">
  <hr>
  <h3> Avoiding Consistency Exceptions Under Strong Memory Models </h3>
    </a><a href="http://zhangminjia.me/">Minjia Zhang</a>,
    <a href="http://users.ices.utexas.edu/~sbiswas/">Swarnendu Biswas</a>, and
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>
    <p>
    ACM SIGPLAN International Symposium on Memory Management
    (<a href="http://conf.researchr.org/home/ismm-2017">ISMM 2017</a>),
    Barcelona, Spain, June 2017
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/avalon-ismm-2017.pdf">PDF</a>
    </p><p>
    <b>Talk:</b> &nbsp;
    <a href="https://docs.google.com/presentation/d/14bbRjLoKRvyjhOLJCDJySYVl_I9NFuCX7ubtLVQ_RGo/edit?usp=sharing">Slides shared in Google Slides</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/57/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
Shared-memory languages and systems generally provide weak or undefined semantics for executions with data races. Prior work has proposed memory consistency models that ensure well-defined, easy-to-understand semantics based on <em>region serializability</em> (RS), but the resulting system may throw a <em>consistency exception</em> in the presence of a data race. Consistency exceptions can occur unexpectedly even in well-tested programs, hurting availability and thus limiting the practicality of RS-based memory models. <p></p><p>To our knowledge, this paper is the first to consider the problem of availability for memory consistency models that throw consistency exceptions. We first extend existing approaches that enforce <em>RSx</em>, a memory model based on serializability of synchronization-free regions (SFRs), to avoid region conflicts and thus consistency exceptions. These new approaches demonstrate both the potential for and limitations of avoiding consistency exceptions under RSx. To improve availability further, we introduce (1) a new memory model called <em>RIx</em> based on <em>isolation</em> of SFRs and (2) a new approach called <em>Avalon</em> that provides RIx. We demonstrate two variants of Avalon that offer different performance–availability tradeoffs for RIx. </p><p>An evaluation on real Java programs shows that this work’s novel approaches are able to reduce consistency exceptions, thereby improving the applicability of strong memory consistency models. Furthermore, the approaches provide compelling points in the performance–availability tradeoff space for memory consistency enforcement. RIx and Avalon thus represent a promising direction for tackling the challenge of availability under strong consistency models that throw consistency exceptions.</p>
    </blockquote>
    <br>

  <a name="legato"></a>
  <hr>
  <h3> Legato: End-to-End Bounded Region Serializability Using Commodity Hardware Transactional Memory  </h3>
    <a href="http://www.cse.ohio-state.edu/~sengupta/">Aritra Sengupta</a>,
    <a href="http://www.cse.ohio-state.edu/~caoma/">Man Cao</a>,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>, and
    <a href="http://engineering.purdue.edu/~milind/">Milind Kulkarni</a>
    <p>
    International Symposium on Code Generation and Optimization
    (<a href="http://cgo.org/cgo2017/">CGO</a>),
    Austin, TX, USA, February 2017
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp; <a href="http://web.cse.ohio-state.edu/~mikebond/legato-cgo-2017-xtr.pdf">Extended technical report</a> (includes appendices) &nbsp; &nbsp; <a href="http://web.cse.ohio-state.edu/~mikebond/legato-cgo-2017.pdf">Conference version</a> (excludes appendices)
    </p><p>
    <b>Talk (by Aritra Sengupta):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/legato-cgo-2017-talk.pptx">PPTX</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/legato-cgo-2017-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="https://sourceforge.net/p/jikesrvm/research-archive/56/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
Shared-memory languages and systems provide strong guarantees only for well-synchronized (data-race-free) programs.
Prior work introduces support for memory consistency based on region serializability of executing code regions,
but all approaches incur serious limitations such as adding high run-time overhead or relying on complex custom hardware.
<p>
This paper explores the potential for leveraging widely available, commodity hardware transactional memory
to provide an end-to-end memory consistency model called <i>dynamically bounded region serializability</i> (DBRS).
To amortize high per-transaction costs, yet mitigate the risk of unpredictable, costly aborts,
we introduce dynamic runtime support called <i>Legato</i> that executes multiple dynamically bounded regions (DBRs)
in a single transaction. Legato varies the number of DBRs per transaction on the fly,
based on the recent history of committed and aborted transactions.
Legato outperforms existing commodity enforcement of DBRS,
and its costs are less sensitive to a program's shared-memory communication patterns. 
These results demonstrate the potential
for providing always-on strong memory consistency using commodity transactional hardware.
    </p></blockquote>
    <br>

  <a name="racechaser-caper"></a>
  <a name="racechaser"></a>
  <a name="caper"></a>
  <a name="litecollider"></a>
  <hr>
  <h3> Lightweight Data Race Detection for Production Runs </h3>
    <a href="http://users.ices.utexas.edu/~sbiswas/">Swarnendu Biswas</a>,
    <a href="http://www.cse.ohio-state.edu/~caoma/">Man Cao</a>,
    <a href="http://zhangminjia.me/">Minjia Zhang</a>,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>, and
    <a href="http://cs.wellesley.edu/~bpw/">Benjamin P. Wood</a>
    <p>
    International Conference on Compiler Construction
    (<a href="http://conf.researchr.org/home/CC-2017">CC</a>),
    Austin, TX, USA, February 2017
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp; <a href="http://web.cse.ohio-state.edu/~mikebond/racechaser-caper-cc-2017.pdf">PDF</a>
    </p><p>
    <b>Talk (by Swarnendu Biswas):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/racechaser-caper-cc-2017-talk.pptx">PPTX</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/racechaser-caper-cc-2017-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="https://sourceforge.net/p/jikesrvm/research-archive/55/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
To detect data races that harm production systems, program analysis must target production runs. However, sound and precise data race detection adds too much run-time overhead for use in production systems. Even existing approaches that provide soundness <i>or</i> precision incur significant limitations.
<p>
This work addresses the need for soundness (no missed races) and precision (no false races) by introducing novel, efficient production-time analyses that address each need separately. (1) <i>Precise</i> data race detection is useful for developers, who want to fix bugs but loathe false positives.
We introduce a precise analysis called <i>RaceChaser</i> that provides low, bounded run-time overhead. (2) <i>Sound</i> race detection benefits analyses and tools whose correctness relies on knowledge of <i>all</i> potential data races. We present a sound, efficient approach called <i>Caper</i> that combines static and dynamic analysis to catch all data races in observed runs. RaceChaser and Caper are useful not only on their own; we introduce a framework that combines these analyses, using Caper as a sound filter for precise data race detection by RaceChaser.
</p><p>
Our evaluation shows that RaceChaser and Caper are efficient and effective, and compare favorably with existing state-of-the-art approaches. These results suggest that RaceChaser and Caper enable practical data race detection that is precise and sound, respectively, ultimately leading to more reliable software systems.
    </p></blockquote>
    <br>

  <a name="prescient-memory">
  <hr>
  <h3> Prescient Memory: Exposing Weak Memory Model Behavior by Looking into the Future  </h3>
    </a><a href="http://www.cse.ohio-state.edu/~caoma/">Man Cao</a>,
    <!--<a href="http://www.cse.ohio-state.edu/~roemerj/">-->Jake Roemer<!--</a>-->,
    <a href="http://www.cse.ohio-state.edu/~sengupta/">Aritra Sengupta</a>, and
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>
    <p>
    ACM SIGPLAN International Symposium on Memory Management
    (<a href="http://conf.researchr.org/home/ismm-2016">ISMM 2016</a>),
    Santa Barbara, CA, USA, June 2016
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/prescient-memory-ismm-2016.pdf">PDF</a>
    </p><p>
    <b>Talk (by Man Cao):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/prescient-memory-ismm-2016-talk.pptx">PPTX</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/prescient-memory-ismm-2016-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/54/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
Shared-memory parallel programs are hard to get right.
A major challenge is
that language and hardware memory models
allow unexpected, erroneous behaviors for executions containing data races.
Researchers have introduced dynamic analyses that expose weak memory model behaviors,
but these approaches cannot expose behaviors due to loading a "future value"—a
value written by a program store that executes <i>after</i> the program load that uses the value.
<p>
This paper presents <i>prescient memory</i> (PM), a novel dynamic analysis that exposes behaviors
due to future values.
PM speculatively returns a future value at a program load, and tries to
validate the speculative value at a later store.
To enable PM to expose behaviors due to future values in real application executions, we introduce a novel approach
that increases the chances of using and successfully validating future values,
by profiling and predicting future values and guiding execution.
Experiments show that our approach is able to uncover a few previously unknown
behaviors due to future values in benchmarked versions of real applications.
Overall, PM overcomes a key limitation of existing approaches, broadening the
scope of program behaviors that dynamic analyses can expose.
    </p></blockquote>
    <br>

  <a name="relaxed-tracking">
  <hr>
  <h3> Relaxed Dependence Tracking for Parallel Runtime Support </h3>
    </a><a href="http://zhangminjia.me/">Minjia Zhang</a>,
    <a href="http://users.ices.utexas.edu/~sbiswas/">Swarnendu Biswas</a>, and
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>
    <p>
    International Conference on Compiler Construction
    (<a href="http://cc2016.eew.technion.ac.il/">CC 2016</a>),
    Barcelona, Spain, March 2016
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/relaxed-tracking-cc-2016.pdf">PDF</a>
    </p><p>

    <b>Talk:</b> &nbsp;
    <a href="https://docs.google.com/presentation/d/1qCfIdbQ1n11LOmlujbwmvvXEyYtscfgRNSA_7jwQrrY/edit?usp=sharing">Slides shared in Google Slides</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/53/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
It is notoriously difficult to achieve
both correctness and scalability
for many shared-memory parallel programs.
To improve correctness and scalability, researchers have developed
various kinds of <i>parallel runtime support</i> such as multithreaded
record &amp; replay and software transactional memory.
Existing forms of runtime support slow programs significantly in order to
track
(i.e., detect or control)
an execution's cross-thread dependences accurately.
<p>
This paper investigates the potential for runtime support to hide latency introduced by dependence tracking,
by tracking dependences
in a <i>relaxed</i> way—meaning that not all dependences are tracked accurately.
The key challenge in relaxing dependence tracking
is to preserve both
the program's semantics
and the runtime support's guarantees.
We present an approach called <i>relaxed tracking</i> (RT)
and demonstrate its potential by building two types of RT-based runtime support.
Our evaluation shows that RT hides much of the latency incurred by dependence tracking,
although RT-based runtime support incurs costs and complexity in order to handle relaxed dependence information.
By demonstrating how to relax dependence tracking to hide latency while preserving correctness,
this work shows the potential for addressing a key cost of dependence tracking,
thus advancing knowledge in the design of parallel runtime support.

    </p></blockquote>
    <br>

  <a name="hybrid-tracking">
  <hr>
  <h3> Drinking from Both Glasses: Combining Pessimistic and Optimistic Tracking of Cross-Thread Dependences  </h3>
    </a><a href="http://www.cse.ohio-state.edu/~caoma/">Man Cao</a>,
    <a href="http://zhangminjia.me/">Minjia Zhang</a>,
    <a href="http://www.cse.ohio-state.edu/~sengupta/">Aritra Sengupta</a>, and
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>
    <p>
    ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming
    (<a href="http://ppopp15.soe.ucsc.edu/">PPoPP 2016</a>),
    Barcelona, Spain, March 2016
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/hybrid-tracking-ppopp-2016.pdf">PDF</a>
    </p><p>
    <b>Talk (by Man Cao):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/hybrid-tracking-ppopp-2016-talk.pptx">PPTX</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/hybrid-tracking-ppopp-2016-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/52/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
It is notoriously challenging to develop parallel software systems that are both scalable and correct. Runtime support for parallelism—such as multithreaded record &amp; replay, data race detectors, transactional memory, and enforcement of stronger memory models—helps achieve these goals, but existing commodity solutions slow programs substantially in order to track (i.e., detect or control) an execution's cross-thread dependences accurately. Prior work tracks cross-thread dependences either "pessimistically," slowing every program access, or "optimistically," allowing for lightweight instrumentation of most accesses but dramatically slowing accesses involved in cross-thread dependences.
<p>
This paper seeks to <i>hybridize</i> pessimistic and optimistic tracking, which is challenging because there exists a fundamental mismatch between pessimistic and optimistic tracking. We address this challenge based on insights about how dependence tracking and program synchronization interact, and introduce a novel approach called <i>hybrid tracking</i>. Hybrid tracking is suitable for building efficient runtime support, which we demonstrate by building hybrid-tracking-based versions of a dependence recorder and a region serializability enforcer. An adaptive, profile-based policy makes run-time decisions about switching between pessimistic and optimistic tracking. Our evaluation shows that hybrid tracking enables runtime support to overcome the performance limitations of both pessimistic and optimistic tracking alone.
    </p></blockquote>
    <br>

  <a name="valor">
  <hr>
  <h3> Valor: Efficient, Software-Only Region Conflict Exceptions  </h3>
    </a><a href="http://users.ices.utexas.edu/~sbiswas/">Swarnendu Biswas</a>,
    <a href="http://zhangminjia.me/">Minjia Zhang</a>,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>, and
    <a href="http://brandonlucia.com/">Brandon Lucia</a>
    <p>
    ACM SIGPLAN International Conference on
    Object-Oriented Programming, Systems, Languages, and Applications
    (<a href="http://2015.splashcon.org/track/oopsla2015">OOPSLA 2015</a>),
    Pittsburgh, PA, USA, October 2015
    </p><p>
    <i>OOPSLA 2015 Distinguished Paper Award</i>
    </p><p>
    <i>OOPSLA 2015 Distinguished Artifact Award</i>
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/valor-oopsla-2015.pdf">PDF</a>
    </p><p>
    <b>Talk (by Swarnendu Biswas):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/valor-oopsla-2015-talk.pptx">PPTX</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/valor-oopsla-2015-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/51/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
Data races complicate programming language semantics, and a data race is often a bug. Existing techniques detect data races and define their semantics by detecting conflicts between <i>synchronization-free regions</i> (SFRs). However, such techniques either modify hardware or slow programs dramatically, preventing always-on use today.
<p>
This paper describes <i>Valor</i>, a sound, precise, software-only region conflict detection analysis that achieves high performance by eliminating the costly analysis on each read operation that prior approaches require. Valor instead logs a region's reads and <i>lazily</i> detects conflicts for logged reads when the region ends. As a comparison, we have also developed <i>FastRCD</i>, a conflict detector that leverages the epoch optimization strategy of the FastTrack data race detector. 
</p><p>
We evaluate Valor, FastRCD, and FastTrack, showing that Valor dramatically outperforms FastRCD and FastTrack. Valor is the first region conflict detector to provide strong semantic guarantees for racy program executions with under 2X slowdown. Overall, Valor advances the state of the art in always-on support for strong behavioral guarantees for data races. 
    </p></blockquote>
    <br>

  <a name="roctet"></a><a name="replay"></a>
  <hr>
  <h3> Efficient Deterministic Replay of Multithreaded Programs Based on Efficient Tracking of Cross-Thread Dependences </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>,
    <a href="http://engineering.purdue.edu/~milind/">Milind Kulkarni</a>,
    <a href="http://www.cse.ohio-state.edu/~caoma/">Man Cao</a>,
    <a href="http://www.cse.ohio-state.edu/~fathi/">Meisam Fathi Salmi</a>, and
    <a href="http://huangjip.github.io/">Jipeng Huang</a>
    <p>
    International Conference on Principles and Practices of Programming on the Java Platform<!--: virtual machines, languages, and tools-->
    (<a href="http://pppj2015.cs.fit.edu/">PPPJ 2015</a>),
    Melbourne, FL, USA, September 2015
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/replay-pppj-2015.pdf">PDF</a>
    </p><p>
    <b>Talk (by Man Cao):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/replay-pppj-2015-talk.pptx">PPTX</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/replay-pppj-2015-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/49/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
Shared-memory
parallel programs are inherently nondeterministic, making it difficult to
diagnose rare bugs and to achieve deterministic execution.
Existing multithreaded record &amp; replay approaches have serious limitations such
as relying on custom hardware,
handling only data-race-free executions,
or slowing programs by an order of magnitude.
Furthermore, language virtual machines (VMs) such as Java VMs (JVMs) introduce
various sources of nondeterminism that thwart demonstrating deterministic replay.
<p>
This paper introduces an approach for multithreaded record &amp; replay based on
tracking and reproducing shared-memory dependences accurately and efficiently.
Building on prior work that introduces an efficient dependence <i>recorder</i>, we
develop a new analysis for <i>replaying</i> dependences.
To demonstrate multithreaded record &amp; replay,
we modify a JVM to
support 
a new methodology that enables demonstrating and evaluating replay in the inherently nondeterministic JVM.
Overall, the performance of both recorded and replayed executions compares favorably with
performance reported by prior work for competing record &amp; replay approaches.
    </p></blockquote>
    <br>

  <a name="hybrid-enforser"></a>
  <hr>
  <h3> Toward Efficient Strong Memory Model Support for the Java Platform via Hybrid Synchronization </h3>
    <a href="http://www.cse.ohio-state.edu/~sengupta/">Aritra Sengupta</a>,
    <a href="http://www.cse.ohio-state.edu/~caoma/">Man Cao</a>,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>, and
    <a href="http://engineering.purdue.edu/~milind/">Milind Kulkarni</a>
    <p>
    International Conference on Principles and Practices of Programming on the Java Platform<!--: virtual machines, languages, and tools-->
    (<a href="http://pppj2015.cs.fit.edu/">PPPJ 2015</a>),
    Melbourne, FL, USA, September 2015
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/hybrid-EnfoRSer-pppj-2015.pdf">PDF</a>
    </p><p>
    <b>Talk (by Aritra Sengupta):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/hybrid-EnfoRSer-pppj-2015-talk.pptx">PPTX</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/hybrid-EnfoRSer-pppj-2015-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/50/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
The Java memory model provides strong behavior guarantees for data-race-free
executions. However, it provides very weak guarantees for racy executions,
leading to unexpected, unintuitive behaviors. This paper focuses on how to
provide a memory model, called <i>statically bounded region serializability</i>
(SBRS), that is substantially stronger than the Java memory model. Our prior
work introduces SBRS, as well as compiler and runtime support for enforcing SBRS
called <i>EnfoRSer</i>. EnfoRSer modifies the dynamic compiler to insert
instrumentation to acquire a lock on each object accessed by the program.
For most programs, EnfoRSer's primary run-time cost is executing this instrumentation
at essentially every memory access.
<p>
This paper focuses on reducing the run-time overhead of enforcing SBRS by
avoiding instrumentation at every memory access that acquires a per-object lock.
We experiment with an alternative approach for providing SBRS that instead
acquires a single <i>static</i> lock before each executed region; all regions
that potentially race with each other—according to a sound whole-program
static analysis—must acquire the same lock. This approach slows most programs
dramatically by needlessly serializing regions that do not actually conflict
with each other. We thus introduce a <i>hybrid</i> approach that judiciously
combines the two locking strategies, using a cost model and run-time profiling.
</p><p>
Our implementation and evaluation in a Java virtual machine use offline profiling and recompilation, thus
demonstrating the potential of the approach without incurring online profiling costs.
The results show that although the overall performance benefit is modest, our hybrid approach
never significantly worsens performance, and for two programs, it significantly outperforms
both approaches that each use only one kind of locking.
These results demonstrate the potential of a technique based on combining synchronization
mechanisms to provide a strong end-to-end memory model for Java and other JVM languages.
    </p></blockquote>
    <br>

  <a name="enforser"></a>
  <hr>
  <h3> Hybrid Static–Dynamic Analysis for Statically Bounded Region Serializability </h3>
    <a href="http://www.cse.ohio-state.edu/~sengupta/">Aritra Sengupta</a>,
    <a href="http://users.ices.utexas.edu/~sbiswas/">Swarnendu Biswas</a>,
    <a href="http://zhangminjia.me/">Minjia Zhang</a>,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>, and
    <a href="http://engineering.purdue.edu/~milind/">Milind Kulkarni</a>
    <!--
    <br>
    Ohio State CSE Technical Report OSU-CISRC-11/12-TR18<br>
    November 2012
    -->
    <p>
    20th International Conference on Architectural Support for Programming Languages and Operating Systems
    (<a href="http://asplos15.bilkent.edu.tr/">ASPLOS 2015</a>),
    Istanbul, Turkey, March 2015
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp; <a href="http://web.cse.ohio-state.edu/~mikebond/EnfoRSer-asplos-2015-xtr.pdf">Extended technical report</a> (includes appendices) &nbsp; &nbsp; <a href="http://web.cse.ohio-state.edu/~mikebond/EnfoRSer-asplos-2015.pdf">Conference version</a> (excludes appendices)
    </p><p>
    <b>Talk (by Aritra Sengupta):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/EnfoRSer-asplos-2015-talk.pptx">PPTX</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/EnfoRSer-asplos-2015-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/48/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
Data races are common. They are difficult to detect, avoid, or eliminate, and programmers sometimes introduce them intentionally.
However, shared-memory programs with data races have unexpected, erroneous behaviors.
Intentional and unintentional data races lead to atomicity and sequential consistency (SC) violations,
and they make it more difficult to understand, test, and verify software.
Existing approaches for providing stronger guarantees for racy executions
add high run-time overhead and/or rely on custom hardware.
<p>
This paper shows how to provide stronger semantics for racy programs while
providing relatively good performance on commodity systems. A novel hybrid
static–dynamic analysis called <i>EnfoRSer</i> provides end-to-end support for a memory model called
<i>statically bounded region serializability</i> (SBRS) that is not only stronger than
weak memory models but is strictly stronger than SC.
EnfoRSer uses static compiler analysis to transform regions,
and dynamic analysis to detect and resolve conflicts at run time.
By demonstrating commodity support for a reasonably strong memory model with reasonable overheads,
we show its potential as an always-on execution model.
    </p></blockquote>
    <br>

  <a name="larktm"></a>
  <hr>
  <h3> Low-Overhead Software Transactional Memory with Progress Guarantees and Strong Semantics </h3>
    <a href="http://zhangminjia.me/">Minjia Zhang</a>,
    <a href="http://huangjip.github.io/">Jipeng Huang</a>,
    <a href="http://www.cse.ohio-state.edu/~caoma/">Man Cao</a>, and
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>
    <p>
    ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming
    (<a href="http://ppopp15.soe.ucsc.edu/">PPoPP 2015</a>),
    San Francisco, CA, USA, February 2015
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp; <a href="http://web.cse.ohio-state.edu/~mikebond/larktm-ppopp-2015.pdf">PDF</a>
    </p><p>
    <b>Talk (by Minjia Zhang):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/larktm-ppopp-2015-talk.pptx">PPTX</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/larktm-ppopp-2015-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    LarkTM (including NOrec and IntelSTM implementations) and our modified port of the STAMP benchmarks are available as separate downloads from the
    <a href="http://www.jikesrvm.org/Resources/ResearchArchive/">Jikes RVM Research Archive</a>.
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
Software transactional memory offers an appealing alternative to locks by
improving programmability, reliability, and scalability.
However, existing STMs are impractical because they add high instrumentation costs
and often provide weak progress guarantees and/or semantics.
<p>
This paper introduces a novel STM called LarkTM that provides three significant features.
(1) Its instrumentation adds low overhead except when accesses actually conflict,
enabling low single-thread overhead and scaling well on low-contention workloads.
(2) It uses eager concurrency control mechanisms, yet naturally supports
flexible conflict resolution, enabling strong progress guarantees.
(3) It naturally provides strong atomicity semantics at low cost.
</p><p>
LarkTM's design works well for low-contention workloads, but adds significant
overhead under higher contention, so we design an <i>adaptive</i> version of LarkTM
that uses alternative
concurrency control for high-contention objects.
</p><p>
An implementation and evaluation in a Java virtual machine show that the basic
and adaptive versions of LarkTM not only provide low single-thread overhead,
but their multithreaded performance compares favorably with existing high-performance STMs.
    </p></blockquote>
    <br>

  <a name="doublechecker"></a>
  <hr>
  <h3> DoubleChecker: Efficient Sound and Precise Atomicity Checking </h3>
    <a href="http://users.ices.utexas.edu/~sbiswas/">Swarnendu Biswas</a>,
    <a href="http://huangjip.github.io/">Jipeng Huang</a>,
    <a href="http://www.cse.ohio-state.edu/~sengupta/">Aritra Sengupta</a>, and
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>
    <p>
    ACM SIGPLAN Conference on Programming Language Design and Implementation
    (<a href="http://conferences.inf.ed.ac.uk/pldi2014/">PLDI 2014</a>),
    Edinburgh, June 2014
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    </p><p>
    <b>Paper:</b> &nbsp; <a href="http://web.cse.ohio-state.edu/~mikebond/doublechecker-pldi-2014.pdf">PDF</a>
    </p><p>
    <b>Talk (by Swarnendu Biswas):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/doublechecker-pldi-2014-talk.pptx">PPTX</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/doublechecker-pldi-2014-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/45/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
Atomicity is a key
correctness property that allows programmers to
reason about code regions in isolation.
However, programs often fail to enforce atomicity correctly, leading to
atomicity
violations that are difficult to detect.
Dynamic program analysis can detect atomicity violations
based on an atomicity specification,
but existing approaches
slow programs substantially.
<p>
This paper presents DoubleChecker, a novel sound and precise atomicity checker
whose key insight lies in its use of two new cooperating dynamic analyses.
Its <i>imprecise</i> analysis tracks cross-thread dependences soundly but
imprecisely with significantly better performance than a fully precise analysis.
Its <i>precise</i> analysis is more expensive but only needs to process a subset of the execution identified
as potentially involved in atomicity violations by the imprecise analysis.
If DoubleChecker operates in <i>single-run</i> mode, the two analyses execute in the same program run,
which guarantees soundness and precision but requires logging program accesses to pass from the imprecise to the precise analysis.
In <i>multi-run</i> mode, the first program run executes only the imprecise analysis,
and a second run executes both analyses. Multi-run mode trades accuracy for performance;
each run of multi-run mode outperforms single-run mode, but can potentially miss violations.
</p><p>
We have implemented DoubleChecker and an existing state-of-the-art atomicity checker
called Velodrome in a high-performance Java virtual machine.  DoubleChecker's single-run mode significantly outperforms 
Velodrome, while still providing full soundness and precision.
DoubleChecker's multi-run mode improves performance further, without significantly impacting soundness in practice.
These results suggest that DoubleChecker's approach is a promising direction for
improving the performance of dynamic atomicity checking over prior work.
    </p></blockquote>
    <br>

  <a name="laminar-toplas"></a>
  <hr>
  <h3> Practical Fine-Grained Information Flow Control Using Laminar </h3>
    <a href="http://www.cs.stonybrook.edu/~porter/">Donald E. Porter</a>,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>,
    <a href="http://www.hpl.hp.com/people/indrajitr/">Indrajit Roy</a>,
    <a href="http://research.microsoft.com/en-us/people/mckinley/">Kathryn S. McKinley</a>, and
    <a href="http://www.cs.utexas.edu/~witchel/">Emmett Witchel</a>
    <p>
    ACM Transactions on Programming Languages and Systems
    (<a href="http://dl.acm.org/citation.cfm?id=J783">TOPLAS</a>),
    November 2014
    </p><p>
    <b>Paper:</b> &nbsp; <a href="http://web.cse.ohio-state.edu/~mikebond/laminar-toplas-2014.pdf">PDF</a>
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/26/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
Decentralized Information Flow Control (DIFC) is a promising model for writing programs with powerful, end-to-end security guarantees. Current DIFC systems that run on commodity hardware can be broadly categorized into two types: language-level and operating system-level DIFC. Language solutions provide no guarantees against security violations on system resources such as files and sockets. Operating system solutions mediate accesses to system resources but are either inefficient or imprecise at monitoring the flow of information through fine-grained program data structures. This article describes Laminar, the first system to implement DIFC using a unified set of abstractions for OS resources and heap-allocated objects. Programmers express security policies by labeling data with secrecy and integrity labels and access the labeled data in <i>security methods</i>. Laminar enforces the security policies specified by the labels at runtime. Laminar is implemented using a modified Java virtual machine and a new Linux security module. This article shows that security methods ease incremental deployment and limit dynamic security checks by retrofitting DIFC policies on four application case studies. Replacing the applications' ad hoc security policies changes less than 10% of the code and incurs performance overheads from 5% to 56%. Compared to prior DIFC systems, Laminar supports a more general class of multithreaded DIFC programs efficiently and integrates language and OS abstractions.
    </blockquote>
    <br>

  <a name="adaptive-sync"></a>
  <hr>
  <h3> Drinking from Both Glasses:
       Adaptively Combining Pessimistic and Optimistic Synchronization for
       Efficient Parallel Runtime Support </h3>
    <a href="http://www.cse.ohio-state.edu/~caoma/">Man Cao</a>,
    <a href="http://zhangminjia.me/">Minjia Zhang</a>, and
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>
    <p>
    Workshop on Determinism and Correctness in Parallel Programming
    (<a href="http://wodet.cs.washington.edu/">WoDet 2014</a>),
    Salt Lake City, March 2014
    </p><p>
    <!--
    <br>
    Acceptance rate: 9 / 11 = ??%
    -->
    <b>Paper:</b> &nbsp;
    <!--<a href=adaptive-sync-wodet-2014.pdf>PDF</a>
    <p>-->
    This paper is <i>subsumed by</i>
    our PPoPP 2016 <a href="http://web.cse.ohio-state.edu/~mikebond/papers.html#hybrid-tracking">paper</a>.
    (If you're interested in the WoDet 2014 paper, it's <a href="http://web.cse.ohio-state.edu/~mikebond/adaptive-sync-wodet-2014.pdf">here</a>.)
    </p><p>
    <!--
    <b>Technical Report (July 2013):</b> &nbsp;
    <a href="adaptive-octet-tr.pdf">PDF</a>
    <p>
    -->
    <b>Talk (by Man Cao):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/adaptive-sync-wodet-2014-talk.pptx">PPTX</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/adaptive-sync-wodet-2014-talk.pdf">PDF</a>
    </p><p>
    <!--
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="http://jikesrvm.org/Research+Archive">Jikes RVM Research Archive</a>
    <p>
    -->
    <b>Abstract:</b>
    </p><blockquote>
It is notoriously challenging to achieve parallel software systems that are both
scalable and reliable. Parallel runtime support—such as multithreaded record
&amp; replay, data race and atomicity violation detectors, transactional memory,
and support for stronger memory models—helps achieve these goals, but existing
commodity solutions slow programs substantially in order to capture (track or
control) the program's cross-thread dependences accurately. Capturing cross-thread
dependences using "pessimistic" synchronization slows every program access, while
"optimistic" synchronization allows for lightweight instrumentation of most
accesses but dramatically slows accesses involved in cross-thread dependences.
<p>
This paper introduces (1) a hybrid of pessimistic and optimistic synchronization
and (2) an adaptive policy that enables fine-grained switching
between pessimistic and optimistic synchronization based on program
behavior. The adaptive policy uses online profiling and a cost–benefit model to
inform its decisions. We design a dependence recorder on top of our approach to
demonstrate its feasibility as a framework for efficient parallel runtime
support.
</p><p>
We have implemented our approach in a high-performance Java virtual machine and
show that it outperforms parallel runtime support based solely on pessimistic or
optimistic synchronization. These results show the potential for adaptive,
hybrid synchronization for efficient parallel runtime support in commodity
systems.
    </p></blockquote>
    <br>

<a name="octet"></a>
  <hr>
  <h3> Octet: Capturing and Controlling Cross-Thread Dependences Efficiently </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>,
    <a href="http://engineering.purdue.edu/~milind/">Milind Kulkarni</a>,
    <a href="http://www.cse.ohio-state.edu/~caoma/">Man Cao</a>,
    <a href="http://zhangminjia.me/">Minjia Zhang</a>,
    <a href="http://www.cse.ohio-state.edu/~fathi/">Meisam Fathi Salmi</a>,
    <a href="http://users.ices.utexas.edu/~sbiswas/">Swarnendu Biswas</a>,
    <a href="http://www.cse.ohio-state.edu/~sengupta/">Aritra Sengupta</a>, and
    <a href="http://huangjip.github.io/">Jipeng Huang</a>
    <p>
    ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
    (<a href="http://splashcon.org/2013/program/oopsla-research-papers">OOPSLA 2013</a>), Indianapolis, IN, USA, October 2013
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/octet-oopsla-2013.pdf">PDF</a>
    </p><p>
    <b>Talk:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/octet-oopsla-2013-talk.pptx">PPTX</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/octet-oopsla-2013-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Our implementation in a JVM is available for download from the
    <a href="https://sourceforge.net/p/jikesrvm/research-archive/43/">Jikes RVM Research Archive</a>
    <p>
    <a href="http://www.cs.hmc.edu/~stone/">Chris Stone</a> from Harvey Mudd
    has implemented Octet for C++11 and made it available
    <a href="https://github.com/christopherastone/octet">here</a>
    </p></blockquote>
    <b>Abstract:</b>
    <blockquote>
Parallel programming is essential for reaping the benefits of parallel hardware,
but it is notoriously difficult to develop and debug reliable, scalable software
systems.  One key challenge is that modern languages and systems provide poor
support for ensuring <i>concurrency correctness properties</i>—atomicity,
sequential consistency, and multithreaded determinism—because all
existing approaches are impractical.  Dynamic, software-based approaches slow
programs by up to an order of magnitude because capturing and controlling cross-thread dependences
(i.e., conflicting accesses to shared memory) requires synchronization at virtually every
access to potentially shared memory.
<p>
This paper introduces a new software-based concurrency control mechanism called
Octet that soundly captures cross-thread dependences and can be used to build
dynamic analyses for concurrency correctness.  Octet achieves low overheads
by tracking the <i>locality state</i> of each potentially shared object. 
Non-conflicting accesses conform to the locality state and require no
synchronization; only conflicting accesses require a state change and
heavyweight synchronization.  This optimistic tradeoff leads to significant
efficiency gains in capturing cross-thread dependences: a prototype
implementation of Octet in a high-performance Java virtual machine slows
real-world concurrent programs by only 26% on average.
A dependence recorder, suitable for record &amp; replay, built on top of Octet adds an additional 5% overhead on average.
These results suggest that Octet can provide a foundation for developing
low-overhead analyses that check and enforce concurrency correctness.
    </p></blockquote>
    <br>

  <a name="ccu"></a>
  <hr>
  <h3> Efficient Context Sensitivity for Dynamic Analyses via
       Calling Context Uptrees and Customized Memory Management </h3>
    <a href="http://huangjip.github.io/">Jipeng Huang</a> and
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>
    <p>
    ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications
    (<a href="http://splashcon.org/2013/program/oopsla-research-papers">OOPSLA 2013</a>), Indianapolis, IN, USA, October 2013
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/ccu-oopsla-2013.pdf">PDF</a>
    </p><p>
    <b>Talk (by Jipeng Huang):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/ccu-oopsla-2013-talk.pptx">PPTX</a> <!-- &nbsp;
    <a href="ccu-oopsla-2013-talk.pdf">PDF</a> -->
    </p><p>
    <b>Source code:</b> &nbsp;
    Available for download from the
    <a href="https://sourceforge.net/p/jikesrvm/research-archive/44/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
State-of-the-art dynamic bug detectors such as data race and memory leak
detectors report program locations that are likely causes of bugs.
However, programmers need more than <i>static</i> program locations to
understand the behavior of increasingly complex and concurrent software.  <i>Dynamic
calling context</i> provides additional information, but it is expensive to record
calling context frequently, e.g., at every read and write.
Context-sensitive dynamic analyses can build and maintain a calling
context tree (CCT) to track calling context—but in order to reuse existing nodes,
CCT-based approaches require an expensive lookup.
<p>
This paper introduces a new approach for context sensitivity that avoids this
expensive lookup.  The approach uses a new data structure called the 
<i>calling context uptree</i> (CCU) that adds low overhead by avoiding the lookup and instead
allocating a new node for each context. A key
contribution is that the approach can mitigate the costs of allocating many nodes by
extending tracing garbage collection (GC): GC collects unused CCU nodes naturally
and efficiently, and we extend GC to merge duplicate nodes lazily.
</p><p>
We implement our CCU-based approach in a high-performance Java virtual
machine and integrate it with a staleness-based memory leak detector and
happens-before data race detector, so they can
report context-sensitive program locations that cause bugs. We show that
the CCU-based approach, in concert with an extended GC, provides a compelling
alternative to CCT-based approaches for adding context sensitivity
to dynamic analyses.
    </p></blockquote>
    <br>

  <a name="leak-chaser"></a>
  <hr>
  <h3> LeakChaser: Helping Programmers Narrow Down Causes of Memory Leaks </h3>
    <a href="http://www.ics.uci.edu/~guoqingx/">Guoqing "Harry" Xu</a>,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>,
    <a href="http://www.cse.ohio-state.edu/~qin/">Feng Qin</a>, and
    <a href="http://www.cse.ohio-state.edu/~rountev/">Atanas Rountev</a>
    <p>
    ACM SIGPLAN Conference on Programming Language Design and Implementation
    (<a href="http://http//pldi11.cs.utah.edu/">PLDI 2011</a>),
    San Jose, CA, USA, June 2011
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/leakchaser-pldi-2011.pdf">PDF</a>
    </p><p>
    <!--
    <b>Talk:</b> &nbsp; 
    <a href="pacer-pldi-2010-talk.pptx">PPTX (version 2007)</a> &nbsp;
    <a href="pacer-pldi-2010-talk.ppt">PPT (versions 97-2003)</a>
    <p>
    -->
    <b>Source code:</b> &nbsp;
    Available for download from the 
    <a href="https://sourceforge.net/p/jikesrvm/research-archive/37/">Jikes RVM Research Archive</a>
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
In large programs written in managed languages such as Java and C#, holding unnecessary
references often results in memory leaks and bloat, degrading
significantly their run-time performance and scalability. Despite the
existence of many leak detectors for such languages, these
detectors often target low-level objects; as a result, their reports
contain many false warnings and lack sufficient semantic information
to help diagnose problems. This paper introduces a specification-based
technique called LeakChaser that can not only capture precisely the
unnecessary references leading to leaks, but also explain, with
high-level semantics, why these references become unnecessary.
<p>
At the heart of LeakChaser is a three-tier approach that uses
varying levels of abstraction to assist programmers with different
skill levels and code familiarity to find leaks. At the highest tier
of the approach, the programmer only needs to specify the boundaries
of coarse-grained activities, referred to as transactions. The tool
automatically infers liveness properties of these transactions, by
monitoring the execution, in order to find unnecessary references.
Diagnosis at this tier can be performed by any programmer after
inspecting the APIs and basic modules of a program, without
understanding of the detailed implementation of these APIs. At the
middle tier, the programmer can introduce application-specific
semantic information by specifying properties for the transactions. At
the lowest tier of the approach is a liveness checker that does not
rely on higher-level semantic information, but rather allows a
programmer to assert lifetime relationships for pairs of objects. This
task could only be performed by skillful programmers who have a clear
understanding of data structures and algorithms in the program.
</p><p>
We have implemented LeakChaser in Jikes RVM and used it to help us
diagnose several real-world leaks. The implementation incurs a
reasonable overhead for debugging and tuning. Our case studies
indicate that the implementation is powerful in guiding programmers
with varying code familiarity to find the root causes of several
memory leaks – even someone who had not studied a leaking program can
quickly find the cause after using LeakChaser's iterative process
that infers and checks properties with different levels of semantic
information.
    </p></blockquote>
    <br>

  <a name="security-policy-oracle"></a>
  <hr>
  <h3> A Security Policy Oracle: Detecting Security Holes Using Multiple API Implementations </h3>
    Varun Srivastava,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>,
    <a href="http://www.cs.utexas.edu/~mckinley/">Kathryn S. McKinley</a>, and
    <a href="http://www.cs.utexas.edu/~shmat/">Vitaly Shmatikov</a>
    <p>
    ACM SIGPLAN Conference on Programming Language Design and Implementation
    (<a href="http://http//pldi11.cs.utah.edu/">PLDI 2011</a>),
    San Jose, CA, USA, June 2011
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/security-policy-oracle-pldi-2011.pdf">PDF</a>
    </p><p>
    <!--
    <b>Talk:</b> &nbsp; 
    <a href="pacer-pldi-2010-talk.pptx">PPTX (version 2007)</a> &nbsp;
    <a href="pacer-pldi-2010-talk.ppt">PPT (versions 97-2003)</a>
    <p>
    -->
    <!--
    <b>Source code:</b> &nbsp;
    Not yet available
    -->
    </p><p>
    <b>Abstract:</b>
    </p><blockquote>
Even experienced developers struggle to implement security policies
correctly.  For example, despite 15 years of development, standard Java
libraries still suffer from missing and incorrectly applied permission
checks, which enable untrusted applications to execute native calls or
modify private class variables without authorization.  Previous techniques
for static verification of authorization enforcement rely on manually
specified policies or attempt to infer the policy by code-mining.  Neither
approach guarantees that the policy used for verification is correct.
<p>
In this paper, we exploit the fact that many modern APIs have
<i>multiple, independent</i> implementations.  Our flow- and
context-sensitive analysis takes as input an API, multiple implementations
thereof, and the definitions of security checks and security-sensitive
events.  For each API entry point, the analysis computes the security
policies enforced by the checks before security-sensitive events such as
native method calls and API
returns, compares these policies across implementations, and reports the
differences.  Unlike code-mining, this technique finds missing checks even
if they are part of a rare pattern.  Security-policy differencing has no
intrinsic false positives: implementations of the same API <i>must</i>
enforce the same policy, or at least one of them is wrong!
</p><p>
Our analysis finds 20 new, confirmed security vulnerabilities and 11
interoperability bugs in the Sun, Harmony, and Classpath implementations
of the Java Class Library, many of which were missed by prior analyses.
These problems manifest in 499 entry points in these mature, well-studied
libraries.  Multiple API implementations are proliferating due to
cloud-based software services and standardization of library interfaces.
Comparing software implementations for consistency is a new approach to
discovering "deep" bugs in them.
    </p></blockquote>
    <br>

  <a name="pacer"></a>
  <hr>
  <h3> Pacer: Proportional Detection of Data Races </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>,
    <a href="http://www.cs.utexas.edu/~coonske/">Katherine E. Coons</a>, and
    <a href="http://www.cs.utexas.edu/~mckinley/">Kathryn S. McKinley</a>
    <p>
    ACM SIGPLAN Conference on Programming Language Design and Implementation
    (<a href="http://www.cs.stanford.edu/pldi10/">PLDI 2010</a>),
    Toronto, June 2010
    <!--
    <br>
    Acceptance rate: 41 / 204 = 20%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/pacer-pldi-2010.pdf">PDF</a> &nbsp;
    (or <a href="http://web.cse.ohio-state.edu/~mikebond/pacer-pldi-2010-xtr.pdf">extended tech report</a> with additional proof details)
    </p><p>
    <b>Talk:</b> &nbsp; 
    <a href="http://web.cse.ohio-state.edu/~mikebond/pacer-pldi-2010-talk.pptx">PPTX (version 2007)</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/pacer-pldi-2010-talk.ppt">PPT (versions 97-2003)</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Available for download from the 
    <a href="https://sourceforge.net/p/jikesrvm/research-archive/28/">Jikes RVM Research Archive</a>
    <p>
    Li, Srisa-an, and Dwyer built on our implementation for their OOPSLA 2011
    <a href="http://dl.acm.org/citation.cfm?id=2048072">paper</a>.
    </p><p>
    Xie and Xue used our implementation for their CGO 2011
    <a href="http://dl.acm.org/citation.cfm?id=2190068">paper</a>.
    </p></blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
Data races indicate serious concurrency bugs such as order, atomicity,
and sequential consistency violations. Races are difficult to
find and fix, often manifesting only after deployment. The frequency
and unpredictability of these bugs will only increase as
software adds parallelism to exploit multicore hardware. Unfortunately,
sound and precise race detectors slow programs by factors
of eight or more and do not scale to large numbers of threads.
</p><p>
This paper presents a precise, low-overhead <i>sampling-based</i>
data race detector called Pacer. Pacer makes a <i>proportionality</i>
guarantee: it detects <i>any</i> race at a rate equal to the sampling rate,
by finding races whose first access occurs during a global sampling
period. During sampling, Pacer tracks all accesses using
the dynamically sound and precise FastTrack algorithm. In non-sampling
periods, Pacer discards sampled access information that
cannot be part of a reported race, <i>and</i> Pacer simplifies tracking
of the happens-before relationship, yielding near-constant, instead
of linear, overheads. Experimental results confirm our theoretical
guarantees. Pacer reports races in proportion to the sampling rate.
Its time and space overheads scale with the sampling rate, and
sampling rates of 1-3% yield overheads low enough to consider
in production software. The resulting system provides a "get what
you pay for" approach that is suitable for identifying real, hard-to-reproduce
races in deployed systems.
    </p></blockquote>
    <br>

  <a name="breadcrumbs"></a>
  <hr>
  <h3> Breadcrumbs: Efficient Context Sensitivity for Dynamic Bug Detection Analyses </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>,
    Graham Z. Baker, and
    <a href="http://www.cs.tufts.edu/~sguyer/">Samuel Z. Guyer</a>
    <p>
    ACM SIGPLAN Conference on Programming Language Design and Implementation
    (<a href="http://www.cs.stanford.edu/pldi10/">PLDI 2010</a>),
    Toronto, June 2010
    <!--
    <br>
    Acceptance rate: 41 / 204 = 20%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/breadcrumbs-pldi-2010.pdf">PDF</a>
    </p><p>
    <b>Talk (by Sam Guyer):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/breadcrumbs-pldi-2010-talk.pptx">PPTX (version 2007)</a> &nbsp; 
    <a href="http://web.cse.ohio-state.edu/~mikebond/breadcrumbs-pldi-2010-talk.ppt">PPT (versions 97-2003)</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Available for download from the 
    <a href="https://sourceforge.net/p/jikesrvm/research-archive/29/">Jikes RVM Research Archive</a>
    </blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
Calling context – the set of active methods on the stack – is critical
for understanding the dynamic behavior of large programs. Dynamic
program analysis tools, however, are almost exclusively context
insensitive because of the prohibitive cost of representing calling
contexts at run time. Deployable dynamic analyses, in particular,
have been limited to reporting only static program locations.
</p><p>
This paper presents Breadcrumbs, an efficient technique for
recording and reporting dynamic calling contexts. It builds on an
existing technique for computing a compact (one word) encoding
of each calling context that client analyses can use in place of a
program location. The key feature of our system is a search algorithm
that can reconstruct a calling context from its encoding using
only a static call graph and a small amount of dynamic information
collected at cold (infrequently executed) callsites. Breadcrumbs requires
no offline training or program modifications, and handles all
language features, including dynamic class loading.
</p><p>
We use Breadcrumbs to add context sensitivity to two dynamic
analyses: a data-race detector and an analysis for diagnosing null
pointer exceptions. On average, it adds 10% to 20% runtime overhead,
depending on a tunable parameter that controls how much dynamic
information is collected. Collecting less information lowers
the overhead, but can result in a search space explosion. In some
cases this causes reconstruction to fail, but in most cases Breadcrumbs
produces non-trivial calling contexts that have the potential
to significantly improve both the precision of the analyses and the
quality of the bug reports.
    </p></blockquote>
    <br>

  <a name="pecan"></a>
  <hr>
  <h3> Efficient, Context-Sensitive Detection of Real-World Semantic Attacks </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>,
    <!--<a href="http://www.cs.utexas.edu/~varun/">-->Varun Srivastava<!--</a>-->,
    <a href="http://www.cs.utexas.edu/~mckinley/">Kathryn S. McKinley</a>, and
    <a href="http://www.cs.utexas.edu/~shmat/">Vitaly Shmatikov</a>
    <p>
    ACM SIGPLAN Workshop on Programming Languages and Analysis for Security
    (<a href="http://software.imdea.org/events/plas2010/index.html">PLAS 2010</a>),
    Toronto, June 2010
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/pecan-plas-2010.pdf">PDF</a> <!-- &nbsp;
    <a href="pecan-plas-2010.ps">PS</a> -->
    </p><p>
    <b>Talk:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/pecan-plas-2010-talk.pptx">PPTX (version 2007)</a> &nbsp; 
    <a href="http://web.cse.ohio-state.edu/~mikebond/pecan-plas-2010-talk.ppt">PPT (versions 97-2003)</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Available for download from the
    <a href="https://sourceforge.net/p/jikesrvm/research-archive/30/">Jikes RVM Research Archive</a>
    </blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
  Software developers are increasingly choosing memory-safe languages.
  As a result, semantic vulnerabilities – omitted security checks,
  misconfigured security policies, and other software design errors – are
  supplanting memory-corruption exploits as the primary cause of security
  violations.  Semantic attacks are difficult to detect because they
  violate <i>program</i> semantics, rather than <i>language</i> semantics.
  This paper presents <i>Pecan</i>, a new dynamic anomaly detector.  Pecan
  identifies unusual program behavior using history sensitivity and
  depth-limited context sensitivity.  Prior work on context-sensitive
  anomaly detection relied on stack-walking, which incurs overheads of
  50% to over 200%.  By contrast, the average overhead of Pecan is
  5%, which is low enough for practical deployment.
  We evaluate Pecan on four representative <i>real-world attacks</i>
  from security vulnerability reports.  These attacks exploit subtle
  bugs in Java applications and libraries, using legal program executions
  that nevertheless violate programmers' expectations.
  Anomaly detection
  must balance precision and sensitivity: high sensitivity leads to
  many benign behaviors appearing anomalous (false positives), while
  low sensitivity may miss attacks.  With application-specific tuning,
  Pecan efficiently tracks depth-limited context and history and reports
  few false positives.
    </p></blockquote>
    <br>

  <a name="leak-pruning"></a>
  <hr>
  <h3> Leak Pruning </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a> and
    <a href="http://www.cs.utexas.edu/~mckinley/">Kathryn S. McKinley</a>
    <p>
    14th International Conference on Architectural Support for Programming Languages and Operating Systems
    (<a href="http://www.cs.virginia.edu/asplos09/">ASPLOS 2009</a>),
    Washington, DC, March 2009
    <!--
    <br>
    Acceptance rate: 29 / 113 = 26%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/leak-pruning-asplos-2009.pdf">PDF</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/leak-pruning-asplos-2009.ps">PS</a>
    </p><p>
    <b>Talk:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/leak-pruning-asplos-2009-talk.pptx">PPT (version 2007)</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/leak-pruning-asplos-2009-talk-ppt2003.ppt">PPT (versions 97-2003)</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/leak-pruning-asplos-2009-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Available for download from the 
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/24/">Jikes RVM Research Archive</a>
    </blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
Managed languages improve programmer productivity with type safety and
garbage collection, which eliminate memory errors such as dangling pointers,
double frees, and buffer overflows.  However, because garbage collection
uses reachability to over-approximate live objects, programs may still
<i>leak</i> memory if programmers forget to eliminate the last reference to
an object that will not be used again.  Leaks slow programs by increasing
collector workload and frequency. Growing leaks eventually crash programs.
</p><p>
This paper introduces <i>leak pruning</i>, which keeps programs running by
predicting and reclaiming leaked objects at run time. It predicts dead
objects and reclaims them based on observing data structure usage patterns.
Leak pruning <i>preserves semantics</i> because it waits for heap exhaustion
before reclaiming objects and <i>poisons</i> references to objects it
reclaims. If the program later tries to access a poisoned reference, the
virtual machine (VM) throws an error.  We show leak pruning has low overhead
in a Java VM and evaluate it on 10 leaking programs. Leak pruning does not
help two programs, executes five substantial programs 1.6-81X longer, and
executes three programs, including a leak in Eclipse, for at least 24 hours.
In the worst case, leak pruning defers fatal errors.  In the best case, it
keeps leaky programs running with preserved semantics and consistent
throughput.
    </p></blockquote>
    <br>

  <a name="laminar"></a>
  <hr>
  <h3> Laminar: Practical Fine-Grained Decentralized Information Flow Control </h3>
    <a href="http://www.cs.utexas.edu/~indrajit/">Indrajit Roy</a>,
    <a href="http://www.cs.utexas.edu/~porterde/">Donald E. Porter</a>,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>,
    <a href="http://www.cs.utexas.edu/~mckinley/">Kathryn S. McKinley</a>, and
    <a href="http://www.cs.utexas.edu/~witchel/">Emmett Witchel</a>
    <p>
    ACM SIGPLAN Conference on Programming Language Design and Implementation
    (<a href="http://www-plan.cs.colorado.edu/~pldi09/">PLDI 2009</a>),
    Dublin, June 2009
    <!--
    <br>
    Acceptance rate: 39 / 196 = 20%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/laminar-pldi-2009.pdf">PDF</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/laminar-pldi-2009.ps">PS</a>
    </p><p>
    <b>Talk (by Indrajit Roy):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/laminar-pldi-2009-talk.pptx">PPT</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    The JVM and OS source are available for download from the 
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/26/">Jikes RVM Research Archive</a>.
    </blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
Decentralized information flow control (DIFC) is a promising model for
writing programs with powerful, end-to-end security guarantees.
Current DIFC systems that run on commodity hardware can be broadly categorized into two
types:  language-level and operating system-level DIFC.
Language level solutions
provide no guarantees against security violations on system resources,
like files and sockets. Operating system solutions
can mediate accesses to system resources, but are
inefficient at monitoring the flow of information through fine-grained
program data structures.
</p><p>
This paper describes Laminar, the first system to implement
decentralized information flow control using a single set of
abstractions for OS resources and heap-allocated objects.
Programmers express security policies by labeling data with secrecy
and integrity labels, and then access the labeled
data in lexically scoped <i>security regions</i>.  Laminar
enforces the security policies specified by the labels at runtime.
Laminar is implemented using a modified Java virtual machine
and a new Linux security module.  This paper shows that security
regions ease incremental deployment and limit dynamic security checks,
allowing us to retrofit DIFC policies on four application case
studies. Replacing the applications' ad-hoc security policies changes less than
10% of the code, and incurs performance overheads from 1% to 56%.
Whereas prior DIFC systems only support limited types of
multithreaded programs, Laminar supports a more general class of
multithreaded DIFC programs that can access heterogeneously labeled
data.
    </p></blockquote>
    <br>

  <a name="thesis"></a>
  <a name="diss"></a>
  <hr>
  <h3> Diagnosing and Tolerating Bugs in Deployed Systems </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael David Bond</a>
    <p>
    Doctoral Dissertation,
    <a href="http://www.cs.utexas.edu/">Department of Computer Sciences</a>,
    <a href="http://www.utexas.edu/">The University of Texas at Austin</a>,
    December 2008
    </p><p>
    <i>ACM SIGPLAN Outstanding Doctoral Dissertation Award (<a href="http://www.sigplan.org/Awards/Dissertation/2008">citation</a>)</i>
    <br>
    <br>
    <b>Document:</b>
    </p><blockquote>
    <a href="http://web.cse.ohio-state.edu/~mikebond/bond-diss-2008.pdf">Official PDF</a> <br>
    <a href="http://web.cse.ohio-state.edu/~mikebond/bond-diss-2008-2.pdf">PDF with 2 pages on a page</a> <!--(recommended for printing)--> <br>
    <a href="http://web.cse.ohio-state.edu/~mikebond/bond-diss-2008-4.pdf">PDF with 4 pages on a page</a> <br>
    <!--<a href="bond-diss-2008-8.pdf">PDF with 8 pages on a page</a> (a bit ridiculous)-->
    </blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
Deployed software is never free of bugs.  These bugs cause
software to fail, wasting billions of dollars and sometimes causing
injury or death. Bugs are pervasive in modern software, which is
increasingly complex due to demand for features, extensibility, and
integration of components. Complete validation and exhaustive testing
are infeasible for substantial software systems, and therefore deployed
software exhibits untested and unanalyzed behaviors.
</p><p>
Software behaves differently after deployment due to different environments
and inputs, so developers cannot find and fix all bugs before deploying
software, and they cannot easily reproduce post-deployment bugs outside of
the deployed setting. This dissertation argues that <i>post-deployment is
a compelling environment</i> for diagnosing and tolerating bugs, and it
introduces a general approach called <i>post-deployment debugging</i>.
Techniques in this class are efficient enough to go unnoticed by users and
accurate enough to find and report the sources of errors to developers.  We
demonstrate that they help developers find and fix bugs and help users get
more functionality out of failing software.
</p><p>
To diagnose post-deployment failures, programmers need to understand the
program operations – control and data flow – responsible for failures. Prior
approaches for widespread tracking of control and data flow often slow
programs by two times or more and increase memory usage significantly,
making them impractical for online use.  We present novel techniques for
representing control and data flow that add modest overhead while still
providing diagnostic information directly useful for fixing bugs.  The first
technique, <i>probabilistic calling context</i> (PCC), provides low-overhead
context sensitivity to dynamic analyses that detect new or anomalous
deployed behavior.
Second, <i>Bell</i> statistically correlates control flow with data, and it
reconstructs program locations associated with data.  We apply Bell to leak
detection, where it tracks and reports program locations responsible for
real memory leaks.  The third technique, <i>origin tracking</i>, tracks the
originating program locations of <i>unusable values</i> such as null
references, by storing origins <i>in place</i> of unusable values.  These
origins are cheap to track and are directly useful for diagnosing real-world
null pointer exceptions.
</p><p>
Post-deployment <i>diagnosis</i> helps developers find and fix bugs, but in
the meantime, users need help with failing software.  We present techniques
that <i>tolerate memory leaks</i>, which are particularly difficult to
diagnose since they have no immediate symptoms and may take days or longer
to materialize.  Our techniques effectively narrow the gap between
reachability and liveness by providing the illusion that dead but reachable
objects do not consume resources.  The techniques identify <i>stale</i>
objects not used in a while and remove them from the application and garbage
collector's working set.
The first technique, <i>Melt</i>, relocates stale memory to disk, so it can
restore objects if the program uses them later.  Growing leaks exhaust the
disk eventually, and some embedded systems have no disk.  Our second
technique, <i>leak pruning</i>, addresses these limitations by automatically
reclaiming likely leaked memory.  It preserves semantics by waiting until
heap exhaustion to reclaim memory – then intercepting program attempts
to access reclaimed memory.
</p><p>
We demonstrate the utility and efficiency of post-deployment debugging on
large, real-world programs – where they pinpoint bug causes and improve
software availability. Post-deployment debugging efficiently exposes and
exploits programming language semantics and opens up a promising direction
for improving software robustness.
    </p></blockquote>
    <br>
<!--
    <b><a href="thesis-abstract.html">Abstract</a></b>
    <br>
    <br>
-->

  <a name="melt"></a>
  <hr>
  <h3> Tolerating Memory Leaks </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a> and
    <a href="http://www.cs.utexas.edu/~mckinley/">Kathryn S. McKinley</a>
    <p>
    23rd Annual International Conference on Object-Oriented Programming, Systems, Languages, and Applications
    (<a href="http://oopsla.org/oopsla2008/">OOPSLA 2008</a>),
    Nashville, October 2008
    <!--
    <br>
    (Previously UT Austin Technical Report TR-07-64, December 2007)
    -->
    <!--
    <br>
    Acceptance rate: ?? / ??? = ??%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/melt-oopsla-2008.pdf">PDF</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/melt-oopsla-2008.ps">PS</a>
    </p><p>
    <b>Talk:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/melt-oopsla-2008-talk.pptx">PPT (version 2007)</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/melt-oopsla-2008-talk-ppt2003.ppt">PPT (versions 97-2003)</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/melt-oopsla-2008-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Available for download from the 
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/23/">Jikes RVM Research Archive</a>
    </blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
    Type safety and garbage collection in managed languages eliminate
    memory errors such as dangling pointers, double frees, and leaks of
    unreachable objects.  Unfortunately, a program still leaks memory
    if it maintains references to objects it will never use again.
    Leaked objects decrease program locality and increase garbage
    collection frequency and workload. A growing leak will eventually
    exhaust memory and crash the program.
    </p><p>
    This paper introduces a <i>leak tolerance</i> approach called
    <i>Melt</i> that safely eliminates performance degradations and
    crashes due to leaks of dead but reachable objects in managed
    languages, given sufficient disk space to hold leaking objects.
    Melt (1) identifies <i>stale</i> objects that the program is not
    accessing; (2) segregates in-use and stale objects by storing stale
    objects to disk; and (3) preserves safety by activating stale
    objects if the program subsequently accesses them.  We design and
    build a prototype implementation of Melt in a Java VM and show it
    adds overhead low enough for production systems. Whereas existing
    VMs grind to a halt and then crash on programs with leaks, Melt
    keeps many of these programs running much longer without
    significantly degrading performance. Melt provides users the
    illusion of a fixed leak and gives developers more time to fix
    leaky programs.
    </p></blockquote>
    <br>

  <a name="pcc"></a>
  <hr>
  <h3> Probabilistic Calling Context </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a> and
    <a href="http://www.cs.utexas.edu/~mckinley/">Kathryn S. McKinley</a>
    <p>
    22nd Annual International Conference on Object-Oriented Programming, Systems, Languages, and Applications
    (<a href="http://oopsla.org/oopsla2007/">OOPSLA 2007</a>),
    Montreal, October 2007
    <!--
    <br>
    Acceptance rate: 33 / 156 = 21%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/pcc-oopsla-2007.pdf">PDF</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/pcc-oopsla-2007.ps">PS</a>
    </p><p>
    <b>Talk:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/pcc-oopsla-2007-talk.ppt">PPT</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/pcc-oopsla-2007-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/18/">Jikes RVM Research Archive</a>
    <p>
    Jones and Ryder used our implementation for context-sensitive allocation sites in their ISMM 2008
    <a href="http://www.cs.kent.ac.uk/pubs/2008/2749/index.html">paper</a>.
    </p></blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
    <i>Calling context</i> enhances program understanding and dynamic 
    analyses by providing a rich representation of program location.  
    Compared to imperative programs, object-oriented programs use more 
    interprocedural and less intraprocedural control flow, increasing 
    the importance of context sensitivity for analysis.  However, prior 
    online methods for computing calling context, such as stack-walking 
    or maintaining the current location in a calling context tree, are 
    expensive in time and space. This paper introduces a new online 
    approach called <i>probabilistic calling context</i> (PCC) that 
    continuously maintains a probabilistically unique value 
    representing the current calling context.  For millions of unique 
    contexts, a 32-bit PCC value has few conflicts.  Computing the PCC 
    value adds 3% average overhead to a Java virtual machine.  PCC is 
    well-suited to clients that detect new or anomalous behavior since 
    PCC values from training and production runs can be compared easily 
    to detect new context-sensitive behavior; clients that query 
    the PCC value at every system call, Java utility call, and Java API 
    call add 0-9% overhead on average.  PCC adds space overhead 
    proportional to the distinct contexts stored by the client (one 
    word per context).  Our results indicate PCC is efficient and 
    accurate enough to use in deployed software for residual testing, 
    bug detection, and intrusion detection.
    </p></blockquote>
    <br>

  <a name="origin-tracking"></a>
  <a name="bad-apples-suite"></a>
  <hr>
  <h3> Tracking Bad Apples: Reporting the Origin of Null and Undefined Value Errors </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>,
    <a href="http://www.valgrind.org/njn/">Nicholas Nethercote</a>,
    Stephen W. Kent,
    <a href="http://www.cs.tufts.edu/~sguyer/">Samuel Z. Guyer</a>, and
    <a href="http://www.cs.utexas.edu/~mckinley/">Kathryn S. McKinley</a>
    <p>
    22nd Annual International Conference on Object-Oriented Programming, Systems, Languages, and Applications
    (<a href="http://oopsla.org/oopsla2007/">OOPSLA 2007</a>),
    Montreal, October 2007
    <!--
    <br>
    Acceptance rate: 33 / 156 = 21%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/origin-tracking-oopsla-2007.pdf">PDF</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/origin-tracking-oopsla-2007.ps">PS</a>
    </p><p>
    <b>Talk:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/origin-tracking-oopsla-2007-talk.ppt">PPT</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/origin-tracking-oopsla-2007-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Both implementations are publicly available:
    <ul>
      <li> Origin tracking for null references in Java is available for download from the
           <a href="http://sourceforge.net/p/jikesrvm/research-archive/19/">Jikes RVM Research Archive</a>
      </li><li> Origin tracking for undefined values in Valgrind's Memcheck tool is available as a branch in the
           <a href="http://valgrind.org/downloads/repository.html">Valgrind Source Code Repository</a>:
           <code>svn://svn.valgrind.org/valgrind/branches/ORIGIN_TRACKING</code>
    </li></ul>
    </blockquote>
    <b>Bug suite: </b>
    <blockquote>
    We've made available 12 Java null pointer exceptions
    as the <a href="http://web.cse.ohio-state.edu/~mikebond/bad-apples-suite.html">Bad Apples Suite</a>.
    </blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
    Programs sometimes crash due to <i>unusable</i> values, for example,
    when Java and C# programs dereference null pointers and when
    C and C++ programs use undefined values to affect program 
    behavior.  A stack trace
    produced on such a crash identifies the effect of the unusable
    value, not its cause, and is often not much help to the
    programmer.
    </p><p>
    This paper presents efficient <i>origin tracking</i> of unusable
    values; it shows how to record where these values come into
    existence, correctly propagate them, and report them if they cause
    an error.  The key idea is <i>value piggybacking</i>: when the
    original program stores an unusable value, value piggybacking
    instead stores origin information in the spare bits of the unusable
    value. Modest compiler support alters the program to
    propagate these modified values through operations such as
    assignments and comparisons.  We evaluate two
    implementations: the first
    tracks null pointer origins in a JVM, and the second tracks
    undefined value origins in a memory-checking tool built with
    Valgrind.  These implementations show that origin tracking via value
    piggybacking is fast and often useful, and in the Java case, has low
    enough overhead for use in a production environment.
    </p></blockquote>
    <br>

  <a name="cgc"></a>
  <hr>
  <h3> Correcting the Dynamic Call Graph Using Control Flow Constraints </h3>
    <a href="http://rsl.gist.ac.kr/~bclee/">Byeongcheol Lee</a>,
    Kevin Resnick,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>, and
    <a href="http://www.cs.utexas.edu/~mckinley/">Kathryn S. McKinley</a>
    <p>
    16th International Conference on Compiler Construction
    (<a href="http://cc2007.cs.brown.edu/">CC 2007</a>),
    Braga, Portugal, March 2007
    <!--
    <br>
    Acceptance rate: 14 / 60 = 23%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/cgc-cc-2007.pdf">PDF</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/cgc-cc-2007.ps">PS</a> &nbsp;
    (A longer <a href="http://web.cse.ohio-state.edu/~mikebond/cgc-techreport-2006.pdf">tech report</a> version includes proofs and algorithms.)
    </p><p>
    <b>Talk (by Byeongcheol Lee):</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/cgc-cc-2007-talk.ppt">PPT</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/20/">Jikes RVM Research Archive</a>
    </blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
    To reason about programs, dynamic optimizers and analysis tools use
    sampling to collect a <i>dynamic call graph</i> (DCG). However,
    sampling has not achieved high accuracy with low runtime overhead. As
    object-oriented programmers compose increasingly complex programs,
    inaccurate call graphs will inhibit analysis and optimizations.
    This paper demonstrates how to use static and dynamic <i>control
    flow graph</i> (CFG) constraints to improve the accuracy of the DCG.
    We introduce the <i>frequency dominator</i> (FDOM), a novel CFG
    relation that extends the dominator relation to expose static
    relative execution frequencies of basic blocks. We combine
    conservation of flow and dynamic CFG basic block profiles to further
    improve the accuracy of the DCG.  Together these approaches add
    minimal overhead (1%) and achieve 85% accuracy compared to a
    perfect call graph for SPEC JVM98 and DaCapo benchmarks.  Compared to
    sampling alone, accuracy improves by 12 to 36%. These results
    demonstrate that static and dynamic control-flow information offer
    accurate information for efficiently improving the DCG.
    </p></blockquote>
    <br>

  <a name="bell"></a>
  <hr>
  <h3> Bell: Bit-Encoding Online Memory Leak Detection </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a> and
    <a href="http://www.cs.utexas.edu/~mckinley/">Kathryn S. McKinley</a>
    <p>
    12th International Conference on Architectural Support for Programming Languages and Operating Systems
    (<a href="http://www.princeton.edu/~asplos06/">ASPLOS-XII</a>),
    San Jose, October 2006
    <!--
    <br>
    Acceptance rate: 38 / 158 = 24%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/bell-asplos-2006.pdf">PDF</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/bell-asplos-2006.ps">PS</a>
    </p><p>
    <b>Talk:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/bell-asplos-2006-talk.ppt">PPT</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/bell-asplos-2006-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/7/">Jikes RVM Research Archive</a>
    <p>
    Tang, Gao, and Qin modified our implementation for their USENIX 2008
    <a href="http://www.cse.ohio-state.edu/~qin/publication.htm">paper</a>.
    </p></blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
    Memory leaks compromise availability and security by crippling
    performance and crashing programs.  Leaks are difficult to diagnose
    because they have no immediate symptoms.  Online leak detection tools
    benefit from storing and reporting per-object <i>sites</i> (e.g.,
    allocation sites) for potentially leaking objects. In programs with
    many small objects, per-object sites add high space overhead,
    limiting their use in production environments.
    </p><p>
    This paper introduces <i>Bit-Encoding Leak Location</i> (Bell), a
    statistical approach that <i>encodes</i> per-object sites to a single
    bit per object.  A bit loses information about a site,
    but given sufficient objects that use the site and a known,
    finite set of possible sites, Bell uses brute-force <i>decoding</i> to
    recover the site with high accuracy.
    </p><p>
    We use this approach to encode object allocation and last-use sites
    in <i>Sleigh</i>, a new leak detection tool.  Sleigh detects
    <i>stale</i> objects (objects unused for a long time) and uses Bell
    decoding to report their allocation and last-use sites.  Our
    implementation steals four unused bits in the object header and thus
    incurs no per-object space overhead.  Sleigh's instrumentation adds
    29% execution time overhead, which adaptive profiling reduces to
    11%.  Sleigh's output is directly useful for finding and fixing
    leaks in SPEC JBB2000 and Eclipse, although sufficiently many objects
    must leak before Bell decoding can report sites with confidence.
    Bell is suitable for other leak detection approaches that store
    per-object sites, and for other problems amenable to statistical
    per-object metadata.
    </p></blockquote>
    <br>

  <a name="pep"></a>
  <hr>
  <h3> Continuous Path and Edge Profiling </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a> and
    <a href="http://www.cs.utexas.edu/~mckinley/">Kathryn S. McKinley</a>
    <p>
    38th International Symposium on Microarchitecture
    (<a href="http://pcsostres.ac.upc.edu/micro38/">MICRO-38</a>),
    <!--pages 130-140,-->
    Barcelona, November 2005
    <!--
    <br>
    Acceptance rate: 29 / 147 = 20%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/pep-micro-2005.pdf">PDF</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/pep-micro-2005.ps">PS</a>
    </p><p>
    <b>Talk:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/pep-micro-2005-talk.ppt">PPT</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/pep-micro-2005-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Available for download from the
    <a href="http://sourceforge.net/p/jikesrvm/research-archive/8/">Jikes RVM Research Archive</a>
    <p>
    D'Elia and Demetrescu modified our path profiling implementation for their OOPSLA 2013
    <a href="http://www.dis.uniroma1.it/~demetres/kstream/kblpp-preprint.pdf">paper</a>.
    </p></blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
    Microarchitectures increasingly rely on dynamic
    optimization to improve performance in ways that are difficult or
    impossible for ahead-of-time compilers.  Dynamic optimizers in turn
    require continuous, portable, low cost, and accurate control-flow
    profiles to inform their decisions, but prior approaches have
    struggled to meet these goals simultaneously.
    </p><p>
    This paper presents PEP, a hybrid instrumentation and sampling
    approach for continuous path and edge profiling that is
    <i>efficient</i>, <i>accurate</i>, and <i>portable</i>.  PEP uses a subset of
    Ball-Larus path profiling to identify paths with low overhead, and
    uses sampling to mitigate the expense of storing paths.  PEP further
    reduces overhead by using profiling to guide instrumentation
    placement.  PEP improves profile accuracy with a modified version of
    Arnold-Grove sampling.  The resulting system has 1.2% average and
    4.3% maximum overhead, 94% path profile accuracy, and 96% edge
    profile accuracy on a set of Java benchmarks.
    </p></blockquote>
    <br>

  <a name="ppp"></a>
  <hr>
  <h3> Practical Path Profiling for Dynamic Optimizers </h3>
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a> and
    <a href="http://www.cs.utexas.edu/~mckinley/">Kathryn S. McKinley</a>
    <p>
    3rd International Symposium on Code Generation and Optimization
    (<a href="http://www.cgo.org/cgo2005/">CGO-3</a>),
    <!--pages 205-216,-->
    San Jose, March 2005
    <!--
    <br>
    Acceptance rate: 26 / 75 = 35%
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/ppp-cgo-2005.pdf">PDF</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/ppp-cgo-2005.ps">PS</a>
    </p><p>
    <b>Talk:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/ppp-cgo-2005-talk.ppt">PPT</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/ppp-cgo-2005-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Available as part of the <a href="http://www.cs.utexas.edu/users/cart/Scale/">Scale</a> compiler.
    <!-- Please contact me if you're interested in using the same version we used in the paper. -->
    <p>
    Vaswani, Nori, and Chilimbi modified our path profiling implementation for their POPL 2007 and FSE 2007
    <a href="http://research.microsoft.com/en-us/projects/ppp">papers</a>.
    </p></blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
    Modern processors are hungry for instructions. To satisfy them,
    compilers need to find and optimize execution paths across multiple
    basic blocks. Path profiles provide this context, but their high
    overhead has so far limited their use by dynamic compilers. We present
    new techniques for low overhead online <i>practical path profiling</i>
    (PPP).
    Following targeted path profiling (TPP), PPP uses an edge profile
    to simplify path profile instrumentation (profile-guided
    profiling). PPP improves over prior work by (1) reducing the amount of
    profiling instrumentation on cold paths and paths that the edge
    profile predicts well and
    (2) reducing the cost of the remaining instrumentation.
    </p><p>
    Experiments in an ahead-of-time compiler
    perform edge profile-guided inlining and unrolling
    prior to path profiling instrumentation.
    These transformations are faithful to staged optimization,
    and create longer, harder to predict paths.
    We introduce the <i>branch-flow</i>
    metric to measure path flow as a function of branch
    decisions, rather than weighting all paths equally as in prior work.
    On SPEC2000, PPP maintains high accuracy and coverage, but has
    only 5% overhead on average (ranging from -3% to 13%),
    making it appealing for use by dynamic compilers.
    </p></blockquote>
    <br>

  <a name="tpp"></a>
  <hr>
  <h3> Targeted Path Profiling: Lower Overhead Path Profiling for Staged Dynamic Optimization Systems </h3>
    Rahul Joshi,
    <a href="http://www.cse.ohio-state.edu/~mikebond/">Michael D. Bond</a>, and
    <a href="http://www-faculty.cs.uiuc.edu/~zilles/">Craig Zilles</a>
    <p>
    2nd International Symposium on Code Generation and Optimization
    (<a href="http://www.cgo.org/cgo2004/">CGO-2</a>),
    <!--pages 239-250,-->
    Palo Alto, March 2004
    <!--
    <br>
    Acceptance rate: 25 / 79 = 32%
    -->
    </p><p>
    <i>Best student presenter</i> <!-- three-way tie -->
    <!--
    <p>
    <i>Nominated for best paper (among five) </i>
    -->
    <br>
    <br>
    <b>Paper:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/tpp-cgo-2004.pdf">PDF</a>
    </p><p>
    <b>Talk:</b> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/tpp-cgo-2004-talk.ppt">PPT</a> &nbsp;
    <a href="http://web.cse.ohio-state.edu/~mikebond/tpp-cgo-2004-talk.pdf">PDF</a>
    </p><p>
    <b>Source code:</b>
    </p><blockquote>
    Subsumed by the <a href="http://web.cse.ohio-state.edu/~mikebond/papers.html#ppp">Practical Path Profiling</a> source code.
    <!-- Please contact me if you're interested in the original Targeted Path Profiling implementation. -->
    </blockquote>
    <b>Abstract:</b>
    <blockquote>
    <p>
    In this paper, we present a technique for reducing the overhead of
    collecting path profiles in the context of a dynamic optimizer.  The
    key idea to our approach, called <i>Targeted Path Profiling</i> (TPP),
    is to use an edge profile to simplify the collection of a path
    profile.  This notion of profile-guided profiling is a natural fit for
    dynamic optimizers, which typically optimize the code in a series of
    stages.
    </p><p>
    TPP is an extension to the Ball-Larus Efficient Path
    Profiling algorithm.  Its increased efficiency comes from two sources:
    (i) reducing the number of potential paths by not enumerating paths
    with cold edges, allowing array accesses to be substituted for more
    expensive hash table lookups, and (ii) not instrumenting regions where
    paths can be unambiguously derived from an edge profile.  Our results
    suggest that on average the overhead of profile collection can be reduced by half (SPEC95) to almost two-thirds (SPEC2000)
    relative to the Ball-Larus algorithm with minimal impact on
    the information collected.
    </p></blockquote>
    <br>

  



<script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?0bd5902d44e80b78cb1cd01ca0e85f4a"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script></body></html>